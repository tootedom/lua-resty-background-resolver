
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    # lua_package_path "/path/to/lua-resty-chash/lib/?.lua;;";
    # lua_package_cpath "/path/to/lua-resty-chash/?.so;;";

    init_worker_by_lua_block {
        local resolver = require 'resty.greencheek.dynamic.background-resolver'
        local config = { dns_resolver = { { '127.0.0.1', 53 } }, refresh_interval = 2 }
        local round_robin_config = { dns_resolver = { { '127.0.0.1', 53 } }, refresh_interval = 2,balancing_type = 'round_robin' }
        memcached_bgdns = resolver.new('mymemcached',config)
        backend_bgdns = resolver.new('localhost',round_robin_config)

        google_bgdns = resolver.new('www.google.com',{ balancing_type = 'round_robin' })
    }

    upstream google {
        server 0.0.0.1;
        balancer_by_lua_block {
            local b = require "ngx.balancer"
            assert(b.set_current_peer(google_bgdns.next(ngx.var.arg_key),1985))
        }
        keepalive 10;
    }

    upstream backend_chash {
        server 0.0.0.1;
        balancer_by_lua_block {
            local b = require "ngx.balancer"
            assert(b.set_current_peer(backend_bgdns.next(ngx.var.arg_key),1985))
        }
        keepalive 10;
    }

    upstream memcached_upstream {
        server 127.0.0.1:11211;
    }

    upstream memcached_upstream2 {
        server 192.168.0.12:11211;
    }

    upstream memcached_upstream_by_balancer {
        server 0.0.0.1;
        balancer_by_lua_block {
            local b = require "ngx.balancer"
            assert(b.set_current_peer(memcached_bgdns.next(ngx.var.arg_key),11211))
        }
        keepalive 10;
    }

    server {
        listen 81;

        location /google {
            proxy_pass https://google/search?q=World+Cup+2018;
            proxy_set_header "User-Agent" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36";
            proxy_redirect     off;
        }

        location /chash {
            set_escape_uri $key $uri$args;
            add_header X-Cache-Status $srcache_fetch_status always;
            add_header X-Cache-Expiry $srcache_expire always;
            srcache_fetch GET /memc key=$key;
            srcache_store PUT /memc key=$key&exptime=$srcache_expire;
            srcache_store_statuses 200 301 302;

            rewrite /chash/(.*) /$1  break;
            proxy_pass http://backend_chash;
            proxy_redirect     off;
            proxy_hide_header Content-Length;


            add_header X-Upstream  $upstream_addr always;
        }

        location = /memc {
            internal;

            set_unescape_uri $exptime $arg_exptime;
            set_unescape_uri $key $arg_key;

            memc_connect_timeout 100ms;
            memc_send_timeout 100ms;
            memc_read_timeout 100ms;
            memc_ignore_client_abort on;

            set $memc_key $key;
            set $memc_exptime $exptime;

            memc_pass memcached_upstream_by_balancer;
        }

        location /stats {
            enhanced_memcached_stats on;
            enhanced_memcached_pass memcached_upstream;
        }

        location /stats2 {
            enhanced_memcached_stats on;
            enhanced_memcached_pass memcached_upstream2;
        }

    }
}
